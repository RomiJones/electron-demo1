#include <node.h>
#include <uv.h>

#ifdef WIN32
#include <windows.h>
#else
#include <sys/syscall.h>
#endif

#include <string>

namespace demo {
	struct Task {
		bool is_error_;
		std::string error_msg_;
		v8::Persistent<v8::Function> callback_;
		std::string param_;
		std::string result_;
		Task() : is_error_(false){}
		Task(bool is_error, std::string error_msg):is_error_(is_error), error_msg_(error_msg) {}
	};

	void Method_f1(const v8::FunctionCallbackInfo<v8::Value>& args) {
#ifdef WIN32
		::MessageBox(NULL, L"调用本地api", L"测试123", 0);
#endif
		v8::Isolate* isolate = args.GetIsolate();
		args.GetReturnValue().Set(v8::String::NewFromUtf8(isolate, "niubi test string"));
	}

	void Method_getCurrentProcessId(const v8::FunctionCallbackInfo<v8::Value>& args) {
        unsigned long processId = 0;
#ifdef WIN32
		processId = GetCurrentProcessId();
#elif defined(_EMACLE_OSX_)
        processId = getpid();
#endif
		v8::Isolate* isolate = args.GetIsolate();
		args.GetReturnValue().Set(v8::Number::New(isolate, processId));
	}

	void Method_syncRunCallback(const v8::FunctionCallbackInfo<v8::Value>& args) {
		v8::Isolate* isolate = args.GetIsolate();
		v8::Local<v8::Function> cb = v8::Local<v8::Function>::Cast(args[0]);
		const unsigned argc = 1;
		v8::Local<v8::Value> argv[argc] = { v8::String::NewFromUtf8(isolate, "hello callback") };
		cb->Call(v8::Null(isolate), argc, argv);
	}

	void WorkAsync(uv_work_t *req);
	void WorkAsyncComplete(uv_work_t *req, int status);
	void Method_asyncRunCallback(const v8::FunctionCallbackInfo<v8::Value>& args) {
		//执行在主线程
#ifdef WIN32
		printf("[thread id %d] %s\n", ::GetCurrentThreadId(), __FUNCTION__);
#endif
		v8::Isolate* isolate = args.GetIsolate();

		if (args.Length() != 2) {
			isolate->ThrowException(v8::Exception::TypeError(v8::String::NewFromUtf8(isolate, "Wrong number of arguments")));
			return;
		}

		if (!args[0]->IsString() || !args[1]->IsFunction()) {
			isolate->ThrowException(v8::Exception::TypeError(v8::String::NewFromUtf8(isolate, "Wrong arguments")));
			return;
		}
		
		v8::String::Utf8Value param0(args[0]->ToString());
		std::string param_str = *param0;

		v8::Local<v8::Function> cb = v8::Local<v8::Function>::Cast(args[1]);

		Task* task = new Task(false, "");
		task->param_ = param_str;
		task->callback_.Reset(isolate, cb);

		uv_work_t* req = new uv_work_t();
		req->data = task;

		uv_queue_work(uv_default_loop(), req, WorkAsync, WorkAsyncComplete);

		args.GetReturnValue().Set(v8::Undefined(isolate));
	}

	void WorkAsync(uv_work_t *req)
	{
#ifdef WIN32
		printf("[thread id %d] %s\n", ::GetCurrentThreadId(), __FUNCTION__);
#endif
		//应该是在libuv的执行消息循环的工作者线程执行，不在主线程
		Task* task = static_cast<Task*>(req->data);
		if (NULL == task) return;

		std::string param = task->param_;

		//do calculate consume cpu
#ifdef WIN32
		::Sleep(5000);
#endif
		task->result_ = "hehe....get result and " + param;
	}

	void WorkAsyncComplete(uv_work_t *req, int status)
	{
#ifdef WIN32
		printf("[thread id %d] %s\n", ::GetCurrentThreadId(), __FUNCTION__);
#endif
		//执行在主线程

		v8::Isolate* isolate = v8::Isolate::GetCurrent();
		v8::HandleScope scope(isolate);

		do
		{
			Task* task = static_cast<Task*>(req->data);
			if (NULL == task) break;
			if(task->is_error_){
				const unsigned argc = 1;
				v8::Local<v8::Value> argv[argc] = {v8::Exception::Error(v8::String::NewFromUtf8(isolate, task->error_msg_.c_str()))};
				v8::Local<v8::Function>::New(isolate, task->callback_)->Call(isolate->GetCurrentContext()->Global(), argc, argv);
			}
			else {
				const unsigned argc = 2;
				v8::Local<v8::Value> argv[argc] = {
					v8::Null(isolate),
					v8::String::NewFromUtf8(isolate, task->result_.c_str())
				};

				v8::Local<v8::Function>::New(isolate, task->callback_)->Call(isolate->GetCurrentContext()->Global(), argc, argv);
			}
			
			task->callback_.Reset();
			delete task;
		} while (0);

		if(req) delete req;
	}

	void init(v8::Local<v8::Object> exports) {
		NODE_SET_METHOD(exports, "f1", Method_f1);
		NODE_SET_METHOD(exports, "getCurrentProcessId", Method_getCurrentProcessId);
		NODE_SET_METHOD(exports, "runSyncCallback", Method_syncRunCallback);
		NODE_SET_METHOD(exports, "runAsyncCallback", Method_asyncRunCallback);
	}

	NODE_MODULE(hello, init)

}  // namespace demo
